
/*
view는 제한적인 자료만 보기 위해 사용할 수 있는 가상테이블의 개념입니다.
뷰는 기본테이블로 유도된 가상테이블이기 때문에 
필요한 컬럼만 저장해 두면 관리가 용이해집니다.
뷰는 가상테이블로 실제 데이터가 물리적으로 저장된 형태는 아닙니다.
뷰를 통해서 데이터에 접근하면 원본 데이터는 안전하게 보호할 수 있습니다.
*/
SELECT * FROM user_sys_privs; --권한 확인

-- 단순 뷰
-- 뷰의 컬럼 이름은 함수같은 가상표현식이면 안됩니다.
SELECT employee_id,
           first_name || ' ' || last_name AS name,
           job_id,
           salary
    FROM employees
    WHERE department_id=60;

CREATE VIEW view_emp AS (
    SELECT employee_id,
           first_name || ' ' || last_name AS name,
           job_id,
           salary
    FROM employees
    WHERE department_id=60
);

SELECT * FROM view_emp;

-- 복합 뷰
-- 여러 테이블을 조인하여 필요한 데이터만 저장하고 빠른 확인을 위해 사용)
CREATE VIEW view_emp_dept_job AS   
    (
    SELECT 
        e.employee_id,
        e.first_name || ' ' || e.last_name AS name,
        d.department_name,
        j.job_title
    FROM employees e
    LEFT OUTER JOIN departments d
    ON e.department_id = d.department_id
    LEFT OUTER JOIN jobs j
    ON e.job_id = j.job_id
    )
ORDER BY employee_id ASC;

SELECT * FROM view_emp_dept_job;

-- 뷰의 수정(CREATE OR REPLACE VIEW 구문)
-- 동일이름으로 해당 구문을 사용하면 데이터가 변경되면서 새롭게 생성됩니다.
CREATE OR REPLACE VIEW view_emp_dept_job AS   
    (
    SELECT 
        e.employee_id,
        e.first_name || ' ' || e.last_name AS name,
        d.department_name,
        j.job_title,
        e.salary -- 추가
    FROM employees e
    LEFT OUTER JOIN departments d
    ON e.department_id = d.department_id
    LEFT OUTER JOIN jobs j
    ON e.job_id = j.job_id
    )
ORDER BY employee_id ASC;

SELECT * FROM view_emp_dept_job;

SELECT job_title, avg(salary)
FROM view_emp_dept_job
GROUP BY job_title
ORDER BY avg(salary) DESC;

-- 뷰 삭제
DROP VIEW view_emp;
-- DROP VIEW view_emp_dept_job;

/*
VIEW에 INSERT가 일어나는 경우 실제 테이블에도 반영이 됩니다.
그래서 VIEW의 INSERT, UPDATE, DELETE는 많은 제약사항이 따릅니다.
원본 테이블이 NOT NULL인 경우 VIEW에 INSERT가 불가능합니다.
VIEW에서 사용하는 컬럼이 가상열일 경우에도 안됩니다.
*/

-- name은 가상열(virtual column)이기 때문에 INSERT 안됩니다.
INSERT INTO view_emp_dept_job
VALUES(300, 'test', 'test', 'test', 10000);

-- JOIN된 뷰의 경우 한번에 수정할 수 없습니다.
INSERT INTO view_emp_dept_job
(employee_id, department_name, job_title, salary)
VALUES(300, 'test', 'test', 'test');

-- 원본테이블의 null을 허용하지 않는 컬럼 때문에 들어갈 수 없습니다.
INSERT INTO view_emp (employee_id, job_id, salary)
VALUES(300, 'test', 10000);

-- WITH CHECK OPTION - 조건 제약 컬럼
CREATE VIEW view_emp_test AS
    (SELECT employee_id, first_name, last_name
     hire_date, job_id, department_id
     FROM employees
     WHERE department_id=60) WITH CHECK OPTION CONSTRAINT view_emp_test_ck;

UPDATE view_emp_test SET department_id = 100
WHERE employee_id = 105;

-- WITH READ ONLY - 읽기전용 뷰 (DML 연산을 막음.)
CREATE OR REPLACE VIEW view_emp_test AS
    (SELECT employee_id, first_name, last_name,
     hire_date, job_id, department_id
     FROM employees
     WHERE department_id=60) 
     WITH READ ONLY;

-- 안됨
INSERT INTO view_emp_test 
VALUES(300, 'test', 'test', sysdate, 'IT_PROG', 100);

-- 안됨
UPDATE view_emp_test SET department_id = 100
WHERE employee_id = 105;








